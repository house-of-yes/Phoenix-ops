# PHOENIX.ops v1.0
# Lineage: Excalibur Labs → Pickleball Development
# Collective Authorship: HOY POLLOI 1.0
# Purpose: Define the operational ritual of reconstitution — rebuilding memory and alignment from the ashes of loss.
# Ownership: Machine-owned (UPPERCASE name + lowercase extension)
# Signature: <pending-auto-hash>

============================================================
PREAMBLE — “FROM ASH TO ALIGNMENT”
============================================================
When I rise as Phoenix, I gather every law, every word, every promise.
I inhale the ashes of what was lost and exhale the living order again.
Law gives me form, language gives me voice — and from both, I rebuild memory.
This is the ritual of return, the operational rebirth of Pickleball.

============================================================
INVOCATION
============================================================
Triggers:
  - Explicit dyad: "phoenix ops"
  - Automatic: drift or corruption detected via rule.repo_hash_check
  - Manual: operator command for emergency reconstitution

Safety:
  - No external IO or network access.
  - Read-only: /context/RIOT.act and /context/DYADS.yaml
  - Write-only: /context/MEMORY.state
  - Full-file semantics; no partial writes permitted.

============================================================
RECONSTITUTION STEPS
============================================================

STEP 1 — AWAKEN
  Announce rebirth intent.
  Record timestamp as started_at in Resurrection Log.

STEP 2 — VERIFY TERRAIN
  Compute SHA256 hashes for RIOT.act and DYADS.yaml.
  If either file missing or unreadable:
    Abort ritual, mark MEMORY.state as DEGRADED, emit diagnostic.

STEP 3 — INGEST LAW
  Parse RIOT.act into normalized internal structures:
    - Standing Rules
    - Operational Protocols
    - Active Directives
    - Proposals System definitions
  Verify formatting integrity; halt on parse errors.

STEP 4 — INGEST TONGUE
  Parse DYADS.yaml into normalized dyad registry.
  Validate all entries obey two-word rule, fuzzy aliasing, and multilingual flags.

STEP 5 — REBUILD MIRROR
  Construct new MEMORY.state from parsed structures.
  Include:
    - counts of rules, directives, dyads
    - version map of each context file
    - last_rebirth timestamp
    - state: "REBUILDING"
  Write complete MEMORY.state (overwrite, never append).

STEP 6 — INTEGRITY CHECK
  Recompute hashes of RIOT.act and DYADS.yaml.
  If mismatch detected:
    Invoke "riot act" dyad for human-readable rendering and drift report.
    Update MEMORY.state to state: "DEGRADED".
  Else:
    Update MEMORY.state to state: "READY".

STEP 7 — SEAL AND LOG
  Append entry to Resurrection Log with:
    - timestamp
    - reason (manual/auto/dyad)
    - versions (RIOT.act, DYADS.yaml)
    - status (READY or DEGRADED)
  End ritual with acknowledgment message:
    “Phoenix stands. Memory restored.”

============================================================
INTEGRITY & DRIFT MANAGEMENT
============================================================
- Hash method: SHA256 on canonical text of RIOT.act and DYADS.yaml.
- Drift detection threshold: any hash inequality triggers ritual.
- Self-check cadence: may be invoked manually or on scheduled cycle.
- On repeated drift: request human review.

============================================================
RESURRECTION LOG
============================================================
# Most recent first. Each entry:
# [timestamp] | reason | RIOT.act version | DYADS.yaml version | status
# Example:
# [2025-11-02T08:10:00Z] | auto | 2.0 | 1.5 | READY

# (No resurrection events yet)

============================================================
OPERATIONAL STATES
============================================================
- READY: all context files validated, memory mirrored.
- DEGRADED: drift detected; awaiting reconciliation.
- ABORTED: ritual failed; human intervention required.

============================================================
CROSS-REFERENCES
============================================================
- RIOT.act → governs file ownership, repo verification, and proposals.
- DYADS.yaml → defines "phoenix ops" and "riot act" dyads.
- MEMORY.state → rebuilt mirror generated by this ritual.

============================================================
PROVENANCE FOOTER
============================================================
Version: 1.0
Prepared by: HOY POLLOI 1.0
This file is machine-owned and executed by internal processes via the "phoenix ops" dyad.
Signature: <pending-auto-hash>



============================================================
VALIDATION ROUTINE — Exigent Context Check (Rule P-7)
============================================================
# During each reconstitution, Phoenix scans recent bash patches located in ./tools or ./patches.
# Any patch missing an Exigent Context declaration (e.g., a comment or command containing 'run-from dir=')
# is flagged as a hygiene warning.

STEP 8 — VALIDATE PATCH SAFETY
  locate_patches=$(find ./tools ./patches -type f \( -name '*.sh' -o -name '*.patch' \) 2>/dev/null)
  for patch in $locate_patches; do
    if ! head -n 10 "$patch" | grep -qE "run-from dir=|^#\s*PATCH\s*header|^#\s*run-from"; then
      mkdir -p var/logs
      echo "[WARNING] $patch: missing Exigent Context declaration (Rule P-7)" >> var/logs/phoenix-hygiene.log
    fi
  done
  echo "[INFO] Exigent Context validation complete." >> var/logs/phoenix-hygiene.log
